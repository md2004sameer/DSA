<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Pathfinding Algorithm Visualization</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1100px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        h2 {
            color: #3498db;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        input, button, select {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .btn-success {
            background-color: #2ecc71;
        }
        
        .btn-success:hover {
            background-color: #27ae60;
        }
        
        .btn-danger {
            background-color: #e74c3c;
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        .btn-warning {
            background-color: #f39c12;
        }
        
        .btn-warning:hover {
            background-color: #d35400;
        }
        
        .grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            overflow: auto;
        }
        
        .grid {
            display: grid;
            gap: 2px;
            background-color: #ddd;
            border: 2px solid #2c3e50;
            padding: 2px;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .cell:hover {
            transform: scale(1.05);
            z-index: 2;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        
        .cell.start {
            background-color: #2ecc71;
            color: white;
        }
        
        .cell.end {
            background-color: #e74c3c;
            color: white;
        }
        
        .cell.obstacle {
            background-color: #7f8c8d;
            color: white;
        }
        
        .cell.current {
            background-color: #3498db;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .cell.visited {
            background-color: #aed6f1;
        }
        
        .cell.path {
            background-color: #f9e79f;
        }
        
        .cell.memoized {
            background-color: #d7bde2;
        }
        
        .cell.considering {
            background-color: #f1c40f;
            color: white;
        }
        
        .call-stack {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: #f8f9fa;
        }
        
        .stack-frame {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }
        
        .stack-frame.active {
            border-left: 4px solid #3498db;
            background-color: #e8f4fc;
            transform: scale(1.02);
        }
        
        .stack-frame.returning {
            border-left: 4px solid #e74c3c;
            background-color: #fdedec;
        }
        
        .path-output {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: #f8f9fa;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #3498db;
            min-height: 100px;
        }
        
        .code-panel {
            font-family: 'Courier New', monospace;
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 15px;
            position: relative;
        }
        
        .code-line {
            padding: 8px 5px;
            margin: 2px 0;
            border-radius: 3px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }
        
        .code-line.active {
            background-color: #3498db;
            transform: scale(1.02);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .code-line.considering {
            background-color: #f39c12;
        }
        
        .code-line-number {
            display: inline-block;
            width: 30px;
            color: #95a5a6;
            font-size: 12px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .metric {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .metric.changed {
            background-color: #e8f4fc;
            transform: scale(1.05);
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
        }
        
        .metric-label {
            font-size: 14px;
            color: #7f8c8d;
        }
        
        .interactive-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .interactive-btn {
            flex: 1;
            min-width: 120px;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes highlight {
            0% { background-color: #f1c40f; }
            100% { background-color: inherit; }
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        
        .error-message {
            background-color: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .status-indicator {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .status-paused {
            background-color: #f39c12;
            color: white;
        }
        
        .status-running {
            background-color: #2ecc71;
            color: white;
        }
        
        .status-stopped {
            background-color: #e74c3c;
            color: white;
        }
        
        .decision-point {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .decision-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .decision-btn {
            flex: 1;
            padding: 8px;
        }
    </style>
</head>
<body>
    <h1>Real-Time Pathfinding Algorithm Visualization</h1>
    
    <div class="error-message" id="error-message"></div>
    
    <div class="container">
        <div class="left-column">
            <div class="panel">
                <h2>Interactive Grid
                    <span class="status-indicator" id="status-indicator">Stopped</span>
                </h2>
                <div class="controls">
                    <input type="number" id="rows" placeholder="Rows" value="4" min="2" max="8">
                    <input type="number" id="cols" placeholder="Columns" value="4" min="2" max="8">
                    <button id="generate-btn">Generate Grid</button>
                    <select id="algorithm-select">
                        <option value="recursive">Recursive (All Paths)</option>
                        <option value="recursive-memo">Recursive with Memoization</option>
                    </select>
                    <button id="toggle-obstacle-btn" class="btn-success">Toggle Obstacle Mode</button>
                </div>
                
                <div class="interactive-controls">
                    <button id="start-btn" class="interactive-btn">Start</button>
                    <button id="pause-btn" class="interactive-btn btn-warning">Pause</button>
                    <button id="step-btn" class="interactive-btn">Step</button>
                    <button id="reset-btn" class="interactive-btn btn-danger">Reset</button>
                    <button id="speed-down-btn" class="interactive-btn">Slower</button>
                    <button id="speed-up-btn" class="interactive-btn">Faster</button>
                </div>
                
                <div class="speed-control">
                    <label for="speed-slider">Animation Speed:</label>
                    <input type="range" id="speed-slider" min="100" max="2000" value="800" step="100">
                    <span id="speed-value">800ms</span>
                </div>
                
                <div class="grid-container">
                    <div id="grid" class="grid"></div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <span>Start</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>End</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>Current</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #aed6f1;"></div>
                        <span>Visited</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f9e79f;"></div>
                        <span>Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #d7bde2;"></div>
                        <span>Memoized</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #7f8c8d;"></div>
                        <span>Obstacle</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f1c40f;"></div>
                        <span>Considering</span>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Found Paths</h2>
                <div id="path-output" class="path-output"></div>
            </div>
        </div>
        
        <div class="right-column">
            <div class="panel">
                <h2>Live Algorithm Execution</h2>
                <div id="code-panel" class="code-panel">
                    <div class="code-line" id="line-1">
                        <span class="code-line-number">1</span>
                        <span>function paths(i, j, m, n, path) {</span>
                    </div>
                    <div class="code-line" id="line-2">
                        <span class="code-line-number">2</span>
                        <span>  if (i == m-1 && j == n-1) {</span>
                    </div>
                    <div class="code-line" id="line-3">
                        <span class="code-line-number">3</span>
                        <span>    print(path); // Found a path!</span>
                    </div>
                    <div class="code-line" id="line-4">
                        <span class="code-line-number">4</span>
                        <span>    return;</span>
                    </div>
                    <div class="code-line" id="line-5">
                        <span class="code-line-number">5</span>
                        <span>  }</span>
                    </div>
                    <div class="code-line" id="line-6">
                        <span class="code-line-number">6</span>
                        <span>  </span>
                    </div>
                    <div class="code-line" id="line-7">
                        <span class="code-line-number">7</span>
                        <span>  if (i < m-1 && !obstacle(i+1, j)) {</span>
                    </div>
                    <div class="code-line" id="line-8">
                        <span class="code-line-number">8</span>
                        <span>    paths(i+1, j, m, n, path + "D");</span>
                    </div>
                    <div class="code-line" id="line-9">
                        <span class="code-line-number">9</span>
                        <span>  }</span>
                    </div>
                    <div class="code-line" id="line-10">
                        <span class="code-line-number">10</span>
                        <span>  </span>
                    </div>
                    <div class="code-line" id="line-11">
                        <span class="code-line-number">11</span>
                        <span>  if (j < n-1 && !obstacle(i, j+1)) {</span>
                    </div>
                    <div class="code-line" id="line-12">
                        <span class="code-line-number">12</span>
                        <span>    paths(i, j+1, m, n, path + "R");</span>
                    </div>
                    <div class="code-line" id="line-13">
                        <span class="code-line-number">13</span>
                        <span>  }</span>
                    </div>
                    <div class="code-line" id="line-14">
                        <span class="code-line-number">14</span>
                        <span>}</span>
                    </div>
                </div>
                
                <div id="decision-point" class="decision-point" style="display: none;">
                    <h3>Decision Point</h3>
                    <p id="decision-text">What should the algorithm do next?</p>
                    <div class="decision-options">
                        <button id="decision-down" class="decision-btn">Move Down</button>
                        <button id="decision-right" class="decision-btn">Move Right</button>
                        <button id="decision-backtrack" class="decision-btn">Backtrack</button>
                        <button id="decision-auto" class="decision-btn">Auto Continue</button>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Live Call Stack</h2>
                <div id="call-stack" class="call-stack"></div>
            </div>
            
            <div class="panel">
                <h2>Real-Time Explanation</h2>
                <div id="explanation" class="explanation">
                    Click "Start" to begin the interactive visualization. You can control the execution speed and make decisions at each step.
                </div>
                
                <div class="metrics">
                    <div class="metric" id="metric-paths">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Paths Found</div>
                    </div>
                    <div class="metric" id="metric-steps">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Steps Taken</div>
                    </div>
                    <div class="metric" id="metric-time">
                        <div class="metric-value">0ms</div>
                        <div class="metric-label">Time Running</div>
                    </div>
                    <div class="metric" id="metric-stack">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Stack Depth</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for real-time execution
        let grid = [];
        let obstacles = new Set();
        let callStack = [];
        let paths = [];
        let isVisualizing = false;
        let isPaused = false;
        let isObstacleMode = false;
        let rows = 4;
        let cols = 4;
        let speed = 800;
        let stepTimeout = null;
        let executionState = null;
        let startTime = 0;
        let stepCount = 0;
        let memo = new Map();
        
        // DOM elements
        const gridElement = document.getElementById('grid');
        const callStackElement = document.getElementById('call-stack');
        const pathOutputElement = document.getElementById('path-output');
        const explanationElement = document.getElementById('explanation');
        const errorMessageElement = document.getElementById('error-message');
        const statusIndicator = document.getElementById('status-indicator');
        const decisionPoint = document.getElementById('decision-point');
        const decisionText = document.getElementById('decision-text');
        const decisionDown = document.getElementById('decision-down');
        const decisionRight = document.getElementById('decision-right');
        const decisionBacktrack = document.getElementById('decision-backtrack');
        const decisionAuto = document.getElementById('decision-auto');
        
        // Control buttons
        const generateBtn = document.getElementById('generate-btn');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stepBtn = document.getElementById('step-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedDownBtn = document.getElementById('speed-down-btn');
        const speedUpBtn = document.getElementById('speed-up-btn');
        const toggleObstacleBtn = document.getElementById('toggle-obstacle-btn');
        const rowsInput = document.getElementById('rows');
        const colsInput = document.getElementById('cols');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const algorithmSelect = document.getElementById('algorithm-select');
        
        // Metrics elements
        const metricPaths = document.getElementById('metric-paths');
        const metricSteps = document.getElementById('metric-steps');
        const metricTime = document.getElementById('metric-time');
        const metricStack = document.getElementById('metric-stack');

        // Initialize the grid
        function initializeGrid() {
            try {
                grid = [];
                obstacles.clear();
                gridElement.innerHTML = '';
                
                // Validate inputs
                rows = parseInt(rowsInput.value) || 4;
                cols = parseInt(colsInput.value) || 4;
                
                if (rows < 2 || rows > 8) {
                    throw new Error("Rows must be between 2 and 8");
                }
                if (cols < 2 || cols > 8) {
                    throw new Error("Columns must be between 2 and 8");
                }
                
                // Set grid styles
                gridElement.style.gridTemplateColumns = `repeat(${cols}, 50px)`;
                gridElement.style.gridTemplateRows = `repeat(${rows}, 50px)`;
                
                // Create cells
                for (let i = 0; i < rows; i++) {
                    grid[i] = [];
                    for (let j = 0; j < cols; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.id = `cell-${i}-${j}`;
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.textContent = `${i},${j}`;
                        
                        if (i === 0 && j === 0) {
                            cell.classList.add('start');
                            cell.textContent = 'S';
                        } else if (i === rows - 1 && j === cols - 1) {
                            cell.classList.add('end');
                            cell.textContent = 'E';
                        }
                        
                        cell.addEventListener('click', handleCellClick);
                        gridElement.appendChild(cell);
                        grid[i][j] = cell;
                    }
                }
                
                hideError();
                resetVisualization();
            } catch (error) {
                showError(error.message);
            }
        }

        // Handle cell click for obstacle toggling
        function handleCellClick(event) {
            if (!isObstacleMode) return;
            
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            // Don't allow obstacles on start or end cells
            if ((row === 0 && col === 0) || (row === rows - 1 && col === cols - 1)) {
                return;
            }
            
            const obstacleKey = `${row},${col}`;
            
            if (obstacles.has(obstacleKey)) {
                obstacles.delete(obstacleKey);
                cell.classList.remove('obstacle');
                cell.textContent = `${row},${col}`;
            } else {
                obstacles.add(obstacleKey);
                cell.classList.add('obstacle');
                cell.textContent = 'X';
            }
        }

        // Show error message
        function showError(message) {
            errorMessageElement.textContent = message;
            errorMessageElement.style.display = 'block';
        }

        // Hide error message
        function hideError() {
            errorMessageElement.style.display = 'none';
        }

        // Update the call stack visualization
        function updateCallStack() {
            callStackElement.innerHTML = '';
            
            // Show the call stack in reverse order (top of stack first)
            for (let i = callStack.length - 1; i >= 0; i--) {
                const frame = callStack[i];
                const frameElement = document.createElement('div');
                frameElement.className = 'stack-frame';
                
                if (i === callStack.length - 1 && !frame.returning) {
                    frameElement.classList.add('active');
                } else if (frame.returning) {
                    frameElement.classList.add('returning');
                }
                
                frameElement.innerHTML = `
                    <div><strong>${frame.function}(${frame.i}, ${frame.j}, ${rows}, ${cols}, "${frame.path}")</strong></div>
                    <div>Position: (${frame.i}, ${frame.j})</div>
                    <div>Path so far: "${frame.path}"</div>
                    ${frame.memoized ? '<div style="color: #8e44ad;">✓ Memoized Result Used</div>' : ''}
                    ${frame.returning ? '<div style="color: #e74c3c;">↩ Returning</div>' : ''}
                `;
                
                callStackElement.appendChild(frameElement);
            }
            
            // Update stack depth metric
            updateMetric(metricStack, callStack.length);
        }

        // Update code highlighting
        function updateCodeHighlight(lineNumber, state = 'active') {
            // Remove active classes from all lines
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('active', 'considering');
            });
            
            // Add appropriate class to current line
            const activeLine = document.getElementById(`line-${lineNumber}`);
            if (activeLine) {
                activeLine.classList.add(state);
            }
        }

        // Update metrics with animation
        function updateMetric(metricElement, value) {
            const valueElement = metricElement.querySelector('.metric-value');
            const currentValue = parseInt(valueElement.textContent) || 0;
            
            if (currentValue !== value) {
                metricElement.classList.add('changed');
                valueElement.textContent = value;
                
                setTimeout(() => {
                    metricElement.classList.remove('changed');
                }, 500);
            }
        }

        // Update all metrics
        function updateMetrics() {
            updateMetric(metricPaths, paths.length);
            updateMetric(metricSteps, stepCount);
            updateMetric(metricTime, performance.now() - startTime);
            updateMetric(metricStack, callStack.length);
        }

        // Reset the visualization
        function resetVisualization() {
            // Clear any running execution
            if (stepTimeout) {
                clearTimeout(stepTimeout);
                stepTimeout = null;
            }
            
            callStack = [];
            paths = [];
            isVisualizing = false;
            isPaused = false;
            executionState = null;
            stepCount = 0;
            startTime = 0;
            memo.clear();
            
            pathOutputElement.textContent = '';
            explanationElement.textContent = 'Click "Start" to begin the interactive visualization. You can control the execution speed and make decisions at each step.';
            decisionPoint.style.display = 'none';
            statusIndicator.textContent = 'Stopped';
            statusIndicator.className = 'status-indicator status-stopped';
            
            // Reset grid cells
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = grid[i][j];
                    cell.className = 'cell';
                    
                    if (obstacles.has(`${i},${j}`)) {
                        cell.classList.add('obstacle');
                        cell.textContent = 'X';
                    } else if (i === 0 && j === 0) {
                        cell.classList.add('start');
                        cell.textContent = 'S';
                    } else if (i === rows - 1 && j === cols - 1) {
                        cell.classList.add('end');
                        cell.textContent = 'E';
                    } else {
                        cell.textContent = `${i},${j}`;
                    }
                }
            }
            
            updateCallStack();
            updateMetrics();
            updateCodeHighlight(0);
        }

        // Check if a cell is an obstacle
        function isObstacle(i, j) {
            return obstacles.has(`${i},${j}`);
        }

        // Highlight a cell considering a move
        function highlightConsideringCell(i, j) {
            if (grid[i] && grid[i][j]) {
                grid[i][j].classList.add('considering');
            }
        }

        // Remove considering highlight from all cells
        function clearConsideringHighlights() {
            document.querySelectorAll('.cell.considering').forEach(cell => {
                cell.classList.remove('considering');
            });
        }

        // The real-time recursive pathfinding algorithm
        function* pathsRecursiveRealTime(i, j, path) {
            stepCount++;
            
            // Add current call to stack
            callStack.push({ function: 'paths', i, j, path, memoized: false });
            updateCallStack();
            
            // Highlight current position
            if (grid[i] && grid[i][j]) {
                grid[i][j].classList.add('current');
            }
            
            // Base case check
            updateCodeHighlight(2);
            explanationElement.textContent = `Checking if we reached the destination: (${i}, ${j}) vs (${rows-1}, ${cols-1})`;
            yield { type: 'base-check', i, j };
            
            if (i === rows - 1 && j === cols - 1) {
                // Found a path!
                updateCodeHighlight(3);
                explanationElement.textContent = `🎉 Destination reached! Found path: "${path}"`;
                paths.push(path);
                pathOutputElement.textContent += path + '\n';
                
                // Mark the path
                if (grid[i] && grid[i][j]) {
                    grid[i][j].classList.remove('current');
                    grid[i][j].classList.add('path');
                }
                
                // Return from this call
                callStack.pop();
                callStack.push({ function: 'paths', i, j, path, returning: true });
                updateCallStack();
                yield { type: 'return', i, j };
                
                callStack.pop();
                updateCallStack();
                return;
            }
            
            // Check and potentially move down
            updateCodeHighlight(7);
            explanationElement.textContent = `Checking if we can move DOWN from (${i}, ${j})`;
            yield { type: 'check-down', i, j };
            
            if (i < rows - 1 && !isObstacle(i+1, j)) {
                highlightConsideringCell(i+1, j);
                updateCodeHighlight(8, 'considering');
                explanationElement.textContent = `Should we move DOWN to (${i+1}, ${j})? Path would be: "${path}D"`;
                
                // Wait for user decision
                const decision = yield { type: 'decision', direction: 'down', i, j, newI: i+1, newJ: j, path: path + "D" };
                
                if (decision === 'down' || decision === 'auto') {
                    clearConsideringHighlights();
                    
                    // Mark current as visited and move
                    if (grid[i] && grid[i][j]) {
                        grid[i][j].classList.remove('current');
                        grid[i][j].classList.add('visited');
                    }
                    
                    // Recursive call for down direction
                    yield* pathsRecursiveRealTime(i+1, j, path + "D");
                    
                    // After returning, highlight current again
                    if (grid[i] && grid[i][j]) {
                        grid[i][j].classList.remove('visited');
                        grid[i][j].classList.add('current');
                    }
                    
                    callStack.push({ function: 'paths', i, j, path, memoized: false });
                    updateCallStack();
                }
            }
            
            // Check and potentially move right
            updateCodeHighlight(11);
            explanationElement.textContent = `Checking if we can move RIGHT from (${i}, ${j})`;
            yield { type: 'check-right', i, j };
            
            if (j < cols - 1 && !isObstacle(i, j+1)) {
                highlightConsideringCell(i, j+1);
                updateCodeHighlight(12, 'considering');
                explanationElement.textContent = `Should we move RIGHT to (${i}, ${j+1})? Path would be: "${path}R"`;
                
                // Wait for user decision
                const decision = yield { type: 'decision', direction: 'right', i, j, newI: i, newJ: j+1, path: path + "R" };
                
                if (decision === 'right' || decision === 'auto') {
                    clearConsideringHighlights();
                    
                    // Mark current as visited and move
                    if (grid[i] && grid[i][j]) {
                        grid[i][j].classList.remove('current');
                        grid[i][j].classList.add('visited');
                    }
                    
                    // Recursive call for right direction
                    yield* pathsRecursiveRealTime(i, j+1, path + "R");
                    
                    // After returning, highlight current again
                    if (grid[i] && grid[i][j]) {
                        grid[i][j].classList.remove('visited');
                        grid[i][j].classList.add('current');
                    }
                    
                    callStack.push({ function: 'paths', i, j, path, memoized: false });
                    updateCallStack();
                }
            }
            
            // Return from this call
            callStack.pop();
            callStack.push({ function: 'paths', i, j, path, returning: true });
            updateCallStack();
            
            explanationElement.textContent = `Returning from paths(${i}, ${j}, ${rows}, ${cols}, "${path}") - no more moves available`;
            yield { type: 'return', i, j };
            
            // Mark as visited when leaving
            if (grid[i] && grid[i][j]) {
                grid[i][j].classList.remove('current');
                grid[i][j].classList.add('visited');
            }
            
            callStack.pop();
            updateCallStack();
        }

        // Start the real-time visualization
        function startVisualization() {
            if (isVisualizing) return;
            
            try {
                resetVisualization();
                isVisualizing = true;
                isPaused = false;
                startTime = performance.now();
                
                // Create generator for the algorithm
                executionState = pathsRecursiveRealTime(0, 0, "");
                
                statusIndicator.textContent = 'Running';
                statusIndicator.className = 'status-indicator status-running';
                
                // Start execution
                executeNextStep();
            } catch (error) {
                showError(`Error starting visualization: ${error.message}`);
                isVisualizing = false;
            }
        }

        // Execute the next step in the algorithm
        function executeNextStep() {
            if (!isVisualizing || isPaused || !executionState) return;
            
            try {
                const result = executionState.next();
                
                if (result.done) {
                    // Algorithm completed
                    isVisualizing = false;
                    statusIndicator.textContent = 'Completed';
                    statusIndicator.className = 'status-indicator status-stopped';
                    explanationElement.textContent = `Algorithm completed! Found ${paths.length} paths.`;
                    return;
                }
                
                const step = result.value;
                
                // Handle different step types
                if (step.type === 'decision') {
                    // Show decision point to user
                    decisionPoint.style.display = 'block';
                    decisionText.textContent = `At position (${step.i}, ${step.j}). ${step.direction === 'down' ? 'Move DOWN to' : 'Move RIGHT to'} (${step.newI}, ${step.newJ})?`;
                    
                    // Set up decision buttons
                    decisionDown.onclick = () => makeDecision('down');
                    decisionRight.onclick = () => makeDecision('right');
                    decisionBacktrack.onclick = () => makeDecision('backtrack');
                    decisionAuto.onclick = () => makeDecision('auto');
                    
                    // Pause execution until decision
                    isPaused = true;
                    statusIndicator.textContent = 'Waiting';
                    statusIndicator.className = 'status-indicator status-paused';
                } else {
                    // Continue with next step after delay
                    stepTimeout = setTimeout(executeNextStep, speed);
                }
                
                updateMetrics();
            } catch (error) {
                showError(`Error during execution: ${error.message}`);
                isVisualizing = false;
            }
        }

        // Make a decision at a decision point
        function makeDecision(decision) {
            if (!executionState || !isPaused) return;
            
            decisionPoint.style.display = 'none';
            isPaused = false;
            
            if (decision === 'backtrack') {
                // For backtracking, we need to modify the generator state
                // This is a simplified approach - in a full implementation, 
                // we'd need more sophisticated generator control
                explanationElement.textContent = "Backtracking to previous decision point...";
                // Note: Full backtracking would require more complex generator management
            } else {
                // Continue with the chosen direction
                executionState.next(decision);
                statusIndicator.textContent = 'Running';
                statusIndicator.className = 'status-indicator status-running';
                executeNextStep();
            }
        }

        // Pause the visualization
        function pauseVisualization() {
            if (!isVisualizing || isPaused) return;
            
            isPaused = true;
            statusIndicator.textContent = 'Paused';
            statusIndicator.className = 'status-indicator status-paused';
            
            if (stepTimeout) {
                clearTimeout(stepTimeout);
                stepTimeout = null;
            }
        }

        // Resume the visualization
        function resumeVisualization() {
            if (!isVisualizing || !isPaused) return;
            
            isPaused = false;
            statusIndicator.textContent = 'Running';
            statusIndicator.className = 'status-indicator status-running';
            executeNextStep();
        }

        // Take a single step
        function stepVisualization() {
            if (!isVisualizing) {
                startVisualization();
                pauseVisualization();
                return;
            }
            
            if (isPaused) {
                // Execute just one step
                const currentPausedState = isPaused;
                isPaused = false;
                executeNextStep();
                // Immediately pause again after one step
                setTimeout(() => {
                    isPaused = currentPausedState;
                    if (isPaused) {
                        statusIndicator.textContent = 'Paused';
                        statusIndicator.className = 'status-indicator status-paused';
                    }
                }, 10);
            }
        }

        // Adjust speed
        function adjustSpeed(delta) {
            speed = Math.max(100, Math.min(2000, speed + delta));
            speedSlider.value = speed;
            speedValue.textContent = `${speed}ms`;
        }

        // Event listeners
        generateBtn.addEventListener('click', initializeGrid);
        startBtn.addEventListener('click', startVisualization);
        pauseBtn.addEventListener('click', pauseVisualization);
        stepBtn.addEventListener('click', stepVisualization);
        resetBtn.addEventListener('click', resetVisualization);
        speedDownBtn.addEventListener('click', () => adjustSpeed(-100));
        speedUpBtn.addEventListener('click', () => adjustSpeed(100));
        
        toggleObstacleBtn.addEventListener('click', () => {
            isObstacleMode = !isObstacleMode;
            toggleObstacleBtn.textContent = isObstacleMode ? 
                "Obstacle Mode: ON" : "Toggle Obstacle Mode";
            toggleObstacleBtn.style.backgroundColor = isObstacleMode ? 
                "#e74c3c" : "#2ecc71";
        });
        
        speedSlider.addEventListener('input', () => {
            speed = parseInt(speedSlider.value);
            speedValue.textContent = `${speed}ms`;
        });

        // Initialize on page load
        window.onload = () => {
            initializeGrid();
        };
    </script>
</body>
</html>